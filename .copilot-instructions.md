# Diretrizes de Desenvolvimento - FIPE App

## üéØ Vis√£o Geral

Este documento define as diretrizes e boas pr√°ticas para o desenvolvimento da aplica√ß√£o FIPE. Todos os desenvolvedores e o GitHub Copilot devem seguir estas orienta√ß√µes.

---

## üìê Arquitetura

### Clean Architecture

O projeto segue os princ√≠pios da Clean Architecture com tr√™s camadas principais:

#### 1. **Domain Layer (Camada de Dom√≠nio)**

- **Responsabilidade**: L√≥gica de neg√≥cio pura
- **Localiza√ß√£o**: `lib/features/[feature]/domain/`
- **Componentes**:
  - **Entities**: Classes de dom√≠nio sem depend√™ncias externas
  - **Repositories**: Interfaces (contratos) abstratas
  - **UseCases**: L√≥gica de neg√≥cio espec√≠fica (Single Responsibility)

**Regras**:

- ‚úÖ Zero depend√™ncias de frameworks externos
- ‚úÖ Entities devem estender `Equatable` para compara√ß√£o
- ‚úÖ UseCases devem ter um √∫nico m√©todo `call()`
- ‚úÖ Repositories s√£o apenas interfaces (abstracts)

**Exemplo de Entity**:

```dart
import 'package:equatable/equatable.dart';

class MarcaEntity extends Equatable {
  final int id;
  final String nome;
  final String tipo;

  const MarcaEntity({
    required this.id,
    required this.nome,
    required this.tipo,
  });

  @override
  List<Object?> get props => [id, nome, tipo];
}
```

**Exemplo de UseCase**:

```dart
abstract class UseCase<Type, Params> {
  Future<Either<Failure, Type>> call(Params params);
}

class GetMarcasPorTipoUseCase implements UseCase<List<MarcaEntity>, TipoVeiculo> {
  final FipeRepository repository;

  GetMarcasPorTipoUseCase(this.repository);

  @override
  Future<Either<Failure, List<MarcaEntity>>> call(TipoVeiculo tipo) async {
    return await repository.getMarcasPorTipo(tipo);
  }
}
```

---

#### 2. **Data Layer (Camada de Dados)**

- **Responsabilidade**: Implementa√ß√£o de acesso a dados
- **Localiza√ß√£o**: `lib/features/[feature]/data/`
- **Componentes**:
  - **Models**: Extens√µes de Entities com `fromJson()` e `toJson()`
  - **DataSources**: Interfaces para APIs e banco local
  - **Repositories**: Implementa√ß√£o dos contratos do Domain

**Regras**:

- ‚úÖ Models estendem Entities
- ‚úÖ Implementar `fromJson()` e `toJson()` em todos os models
- ‚úÖ DataSources sempre com interface e implementa√ß√£o separadas
- ‚úÖ Repositories convertem Models em Entities
- ‚úÖ Tratamento de exce√ß√µes nos DataSources

**Exemplo de Model**:

```dart
class MarcaModel extends MarcaEntity {
  const MarcaModel({
    required super.id,
    required super.nome,
    required super.tipo,
  });

  factory MarcaModel.fromJson(Map<String, dynamic> json) {
    return MarcaModel(
      id: json['id'] as int,
      nome: json['nome'] as String,
      tipo: json['tipo'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'nome': nome,
      'tipo': tipo,
    };
  }
}
```

**Exemplo de Repository Implementation**:

```dart
class FipeRepositoryImpl implements FipeRepository {
  final SupabaseDataSource remoteDataSource;
  final LocalDataSource localDataSource;

  FipeRepositoryImpl({
    required this.remoteDataSource,
    required this.localDataSource,
  });

  @override
  Future<Either<Failure, List<MarcaEntity>>> getMarcasPorTipo(TipoVeiculo tipo) async {
    try {
      final marcas = await remoteDataSource.getMarcasByTipo(tipo);
      return Right(marcas);
    } on ServerException {
      return Left(ServerFailure());
    }
  }
}
```

---

#### 3. **Presentation Layer (Camada de Apresenta√ß√£o)**

- **Responsabilidade**: UI e gerenciamento de estado
- **Localiza√ß√£o**: `lib/features/[feature]/presentation/`
- **Componentes**:
  - **BLoC/Cubit**: Gerenciamento de estado
  - **Pages**: Telas completas
  - **Widgets**: Componentes reutiliz√°veis

**Regras**:

- ‚úÖ Usar `flutter_bloc` para gerenciamento de estado
- ‚úÖ BLoCs/Cubits devem ser injetados via GetIt
- ‚úÖ Widgets devem ser stateless quando poss√≠vel
- ‚úÖ Separar l√≥gica de apresenta√ß√£o da UI

**Exemplo de BLoC**:

```dart
class MarcaBloc extends Bloc<MarcaEvent, MarcaState> {
  final GetMarcasPorTipoUseCase getMarcasPorTipo;

  MarcaBloc({required this.getMarcasPorTipo}) : super(MarcaInitial()) {
    on<GetMarcasEvent>(_onGetMarcas);
  }

  Future<void> _onGetMarcas(
    GetMarcasEvent event,
    Emitter<MarcaState> emit,
  ) async {
    emit(MarcaLoading());

    final result = await getMarcasPorTipo(event.tipo);

    result.fold(
      (failure) => emit(MarcaError(message: _mapFailureToMessage(failure))),
      (marcas) => emit(MarcaLoaded(marcas: marcas)),
    );
  }
}
```

---

## üèõÔ∏è Princ√≠pios SOLID

### 1. **Single Responsibility Principle (SRP)**

- Cada classe deve ter apenas uma raz√£o para mudar
- UseCases devem ter apenas um m√©todo `call()`
- Widgets complexos devem ser quebrados em componentes menores

**‚ùå Errado**:

```dart
class VeiculoService {
  Future<List<Marca>> getMarcas() {}
  Future<List<Modelo>> getModelos() {}
  Future<void> saveFavorite() {}
  Future<void> shareVeiculo() {}
}
```

**‚úÖ Correto**:

```dart
class GetMarcasUseCase { /* ... */ }
class GetModelosUseCase { /* ... */ }
class SaveFavoriteUseCase { /* ... */ }
class ShareVeiculoUseCase { /* ... */ }
```

---

### 2. **Open/Closed Principle (OCP)**

- Classes devem ser abertas para extens√£o, fechadas para modifica√ß√£o
- Usar abstra√ß√µes e interfaces

**‚úÖ Exemplo**:

```dart
abstract class DataSource {
  Future<List<MarcaModel>> getMarcas();
}

class SupabaseDataSourceImpl implements DataSource { /* ... */ }
class MockDataSourceImpl implements DataSource { /* ... */ }
```

---

### 3. **Liskov Substitution Principle (LSP)**

- Subtipos devem ser substitu√≠veis por seus tipos base
- Models devem poder ser usados onde Entities s√£o esperadas

---

### 4. **Interface Segregation Principle (ISP)**

- N√£o force classes a implementar interfaces que n√£o usam
- Divida interfaces grandes em menores e espec√≠ficas

**‚ùå Errado**:

```dart
abstract class FipeRepository {
  Future<List<Marca>> getMarcas();
  Future<List<Modelo>> getModelos();
  Future<void> saveFavorite();
  Future<void> shareVeiculo();
}
```

**‚úÖ Correto**:

```dart
abstract class FipeRepository {
  Future<List<Marca>> getMarcas();
  Future<List<Modelo>> getModelos();
}

abstract class FavoriteRepository {
  Future<void> saveFavorite();
  Future<void> deleteFavorite();
}
```

---

### 5. **Dependency Inversion Principle (DIP)**

- Dependa de abstra√ß√µes, n√£o de implementa√ß√µes concretas
- Use inje√ß√£o de depend√™ncias (GetIt)

**‚úÖ Exemplo**:

```dart
// Depende de abstra√ß√£o
class MarcaBloc {
  final FipeRepository repository; // Interface, n√£o implementa√ß√£o
  MarcaBloc({required this.repository});
}

// Configura√ß√£o no injection_container.dart
sl.registerLazySingleton<FipeRepository>(
  () => FipeRepositoryImpl(
    remoteDataSource: sl(),
    localDataSource: sl(),
  ),
);
```

---

## üîß Inje√ß√£o de Depend√™ncias

### GetIt Configuration

**Arquivo**: `lib/injection_container.dart`

```dart
final sl = GetIt.instance;

Future<void> init() async {
  // ‚úÖ BLoCs - Factory (nova inst√¢ncia a cada chamada)
  sl.registerFactory(
    () => MarcaBloc(getMarcasPorTipo: sl()),
  );

  // ‚úÖ UseCases - Lazy Singleton
  sl.registerLazySingleton(() => GetMarcasPorTipoUseCase(sl()));

  // ‚úÖ Repositories - Lazy Singleton
  sl.registerLazySingleton<FipeRepository>(
    () => FipeRepositoryImpl(
      remoteDataSource: sl(),
      localDataSource: sl(),
    ),
  );

  // ‚úÖ DataSources - Lazy Singleton
  sl.registerLazySingleton<SupabaseDataSource>(
    () => SupabaseDataSourceImpl(client: sl()),
  );

  // ‚úÖ External - Singleton
  final supabase = await Supabase.initialize(
    url: SupabaseConfig.supabaseUrl,
    anonKey: SupabaseConfig.supabaseAnonKey,
  );
  sl.registerSingleton<SupabaseClient>(supabase.client);
}
```

---

## üé® Padr√µes de C√≥digo

### Nomenclatura

- **Classes**: PascalCase (`MarcaEntity`, `GetMarcasUseCase`)
- **Arquivos**: snake_case (`marca_entity.dart`, `get_marcas_usecase.dart`)
- **Vari√°veis**: camelCase (`marcaEntity`, `isLoading`)
- **Constantes**: lowerCamelCase (`appTitle`, `defaultTimeout`)

### Estrutura de Arquivos

```
lib/features/consulta_fipe/
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ datasources/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ supabase_data_source.dart
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ local_data_source.dart
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ marca_model.dart
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modelo_model.dart
‚îÇ   ‚îî‚îÄ‚îÄ repositories/
‚îÇ       ‚îî‚îÄ‚îÄ fipe_repository_impl.dart
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ marca_entity.dart
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modelo_entity.dart
‚îÇ   ‚îú‚îÄ‚îÄ repositories/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ fipe_repository.dart
‚îÇ   ‚îî‚îÄ‚îÄ usecases/
‚îÇ       ‚îú‚îÄ‚îÄ get_marcas_por_tipo_usecase.dart
‚îÇ       ‚îî‚îÄ‚îÄ get_modelos_por_marca_usecase.dart
‚îî‚îÄ‚îÄ presentation/
    ‚îú‚îÄ‚îÄ bloc/
    ‚îÇ   ‚îú‚îÄ‚îÄ marca_bloc.dart
    ‚îÇ   ‚îú‚îÄ‚îÄ marca_event.dart
    ‚îÇ   ‚îî‚îÄ‚îÄ marca_state.dart
    ‚îú‚îÄ‚îÄ pages/
    ‚îÇ   ‚îú‚îÄ‚îÄ marca_list_page.dart
    ‚îÇ   ‚îî‚îÄ‚îÄ modelo_list_page.dart
    ‚îî‚îÄ‚îÄ widgets/
        ‚îú‚îÄ‚îÄ marca_item_widget.dart
        ‚îî‚îÄ‚îÄ loading_widget.dart
```

---

## üß™ Testes

### Cobertura M√≠nima: 80%

#### Testes Unit√°rios

```dart
// test/features/consulta_fipe/domain/usecases/get_marcas_por_tipo_usecase_test.dart

void main() {
  late GetMarcasPorTipoUseCase usecase;
  late MockFipeRepository mockRepository;

  setUp(() {
    mockRepository = MockFipeRepository();
    usecase = GetMarcasPorTipoUseCase(mockRepository);
  });

  test('deve retornar lista de marcas quando repository retornar sucesso', () async {
    // Arrange
    when(mockRepository.getMarcasPorTipo(any))
        .thenAnswer((_) async => Right(tMarcaList));

    // Act
    final result = await usecase(TipoVeiculo.carro);

    // Assert
    expect(result, Right(tMarcaList));
    verify(mockRepository.getMarcasPorTipo(TipoVeiculo.carro));
    verifyNoMoreInteractions(mockRepository);
  });
}
```

---

## üöÄ Boas Pr√°ticas

### 1. **Tratamento de Erros**

```dart
// lib/core/error/failures.dart
abstract class Failure extends Equatable {
  @override
  List<Object> get props => [];
}

class ServerFailure extends Failure {}
class CacheFailure extends Failure {}
class NetworkFailure extends Failure {}

// lib/core/error/exceptions.dart
class ServerException implements Exception {}
class CacheException implements Exception {}
```

### 2. **Constants**

```dart
// lib/core/constants/app_constants.dart
class AppConstants {
  static const String appName = 'FIPE Consulta';
  static const int cacheTimeout = 3600; // 1 hora
  static const int paginationLimit = 50;
}
```

### 3. **Extensions**

```dart
// lib/core/extensions/string_extensions.dart
extension StringExtension on String {
  String capitalize() {
    return "${this[0].toUpperCase()}${substring(1)}";
  }
}
```

### 4. **Widgets Reutiliz√°veis**

- Sempre extrair widgets complexos
- Usar `const` sempre que poss√≠vel
- Criar widgets em `lib/core/widgets/` se usados em m√∫ltiplas features

---

## üì± UI/UX Guidelines

### Material Design 3

- Usar componentes do Material 3
- Seguir paleta de cores definida em `app_theme.dart`
- Garantir contraste adequado (WCAG AA)

### Responsividade

- Testar em m√∫ltiplos tamanhos de tela
- Usar `MediaQuery` e `LayoutBuilder`
- Suportar orienta√ß√£o portrait e landscape

### Performance

- Lazy loading em listas longas
- Image caching com `cached_network_image`
- Debounce em campos de busca (300ms)
- Usar `const` construtores sempre que poss√≠vel

---

## üîí Seguran√ßa

### Configura√ß√µes Sens√≠veis

- **NUNCA** commitar credenciais no Git
- Usar arquivos `.gitignore` para `supabase_config.dart` e `admob_config.dart`
- Vari√°veis sens√≠veis em GitHub Secrets para CI/CD

### Row Level Security (RLS)

- Todas as tabelas do Supabase devem ter RLS habilitado
- Apenas leitura p√∫blica para dados FIPE

---

## üìä CI/CD

### ‚ö†Ô∏è OBRIGAT√ìRIO: Antes de Cada Commit

**IMPORTANTE**: Sempre execute os seguintes comandos antes de commitar qualquer c√≥digo:

```bash
# 1. Verificar formata√ß√£o
flutter format .

# 2. Analisar c√≥digo (OBRIGAT√ìRIO - deve retornar 0 issues)
flutter analyze

# 3. Executar testes (OBRIGAT√ìRIO - todos devem passar)
flutter test

# 4. Verificar cobertura (opcional, mas recomendado)
flutter test --coverage
```

**‚ùå N√ÉO COMMITE SE:**

- `flutter analyze` retornar warnings ou erros
- `flutter test` tiver testes falhando
- Houver c√≥digo n√£o formatado

**‚úÖ S√ì COMMITE QUANDO:**

- Todos os testes passarem
- `flutter analyze` n√£o retornar issues
- C√≥digo estiver formatado

### GitHub Actions

- Build automatizado em cada push
- Testes obrigat√≥rios antes de merge
- Deploy automatizado com tags `v*.*.*`

---

## üìù Documenta√ß√£o

### Coment√°rios de C√≥digo

- Usar `///` para documenta√ß√£o p√∫blica
- Explicar o "porqu√™", n√£o o "o qu√™"
- Documentar par√¢metros complexos

```dart
/// Busca marcas de ve√≠culos por tipo.
///
/// Retorna uma lista de [MarcaEntity] ou uma [Failure] em caso de erro.
/// O par√¢metro [tipo] define se √© carro, moto ou caminh√£o.
Future<Either<Failure, List<MarcaEntity>>> getMarcasPorTipo(TipoVeiculo tipo);
```

---

## ‚úÖ Checklist de Code Review

- [ ] Segue Clean Architecture (Domain ‚Üí Data ‚Üí Presentation)
- [ ] Aplica princ√≠pios SOLID
- [ ] Usa inje√ß√£o de depend√™ncias (GetIt)
- [ ] Tem testes unit√°rios (cobertura > 80%)
- [ ] Sem depend√™ncias desnecess√°rias
- [ ] C√≥digo formatado (`flutter format`)
- [ ] Sem warnings no Analyzer
- [ ] Widgets s√£o `const` quando poss√≠vel
- [ ] Tratamento de erros implementado
- [ ] Documenta√ß√£o adequada

---

## üéØ Objetivos de Qualidade

| M√©trica              | Alvo   |
| -------------------- | ------ |
| Cobertura de Testes  | > 80%  |
| Warnings do Analyzer | 0      |
| Tempo de Build       | < 2min |
| Tamanho do APK       | < 20MB |
| Tempo de Startup     | < 3s   |

---

**√öltima atualiza√ß√£o**: 16 de dezembro de 2024
